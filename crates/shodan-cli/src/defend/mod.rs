//! Defense module: geo-blocking, IP banning, firewall rule generation.

use anyhow::Result;
use directories::ProjectDirs;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Defense state - what's currently blocked.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct State {
    /// Blocked country codes (ISO 2-letter, lowercase).
    pub blocked_countries: Vec<String>,

    /// Blocked IP addresses and CIDR ranges.
    pub blocked_ips: Vec<String>,

    /// Blocked AS numbers (e.g., "AS12345").
    pub blocked_asns: Vec<String>,

    /// Whitelisted IPs (never blocked).
    pub whitelisted_ips: Vec<String>,
}

impl State {
    /// Get the state file path.
    pub fn path() -> Result<PathBuf> {
        let dirs = ProjectDirs::from("is", "i1", "showdi1")
            .ok_or_else(|| anyhow::anyhow!("Could not determine config directory"))?;

        Ok(dirs.data_dir().join("defend_state.json"))
    }

    /// Load state from file.
    pub fn load() -> Result<Self> {
        let path = Self::path()?;

        if !path.exists() {
            return Ok(Self::default());
        }

        let content = std::fs::read_to_string(&path)?;
        let state: State = serde_json::from_str(&content)?;

        Ok(state)
    }

    /// Save state to file.
    pub fn save(&self) -> Result<()> {
        let path = Self::path()?;

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(&path, content)?;

        Ok(())
    }
}

/// Geo-blocking operations.
pub struct GeoBlock;

/// IP set operations.
pub struct IpSet;

/// Get country name from code.
pub fn country_name(code: &str) -> &'static str {
    match code.to_lowercase().as_str() {
        "cn" => "China",
        "ru" => "Russia",
        "us" => "United States",
        "ro" => "Romania",
        "pl" => "Poland",
        "kz" => "Kazakhstan",
        "ua" => "Ukraine",
        "vn" => "Vietnam",
        "br" => "Brazil",
        "in" => "India",
        "kr" => "South Korea",
        "de" => "Germany",
        "fr" => "France",
        "gb" | "uk" => "United Kingdom",
        "jp" => "Japan",
        "nl" => "Netherlands",
        "th" => "Thailand",
        "id" => "Indonesia",
        "ca" => "Canada",
        "au" => "Australia",
        "mx" => "Mexico",
        "it" => "Italy",
        "es" => "Spain",
        "ar" => "Argentina",
        "eg" => "Egypt",
        "za" => "South Africa",
        "ng" => "Nigeria",
        "pk" => "Pakistan",
        "bd" => "Bangladesh",
        "ph" => "Philippines",
        "my" => "Malaysia",
        "sg" => "Singapore",
        "hk" => "Hong Kong",
        "tw" => "Taiwan",
        "ir" => "Iran",
        "kp" => "North Korea",
        _ => "Unknown",
    }
}

/// Generate nftables rules from state.
pub fn generate_nftables(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("#!/usr/sbin/nft -f\n");
    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Apply with: nft -f <filename>\n\n");

    rules.push_str("table inet geoblock {\n");

    // Whitelist set
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("    set whitelist {\n");
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        elements = { ");
        rules.push_str(&state.whitelisted_ips.join(", "));
        rules.push_str(" }\n");
        rules.push_str("    }\n\n");
    }

    // Blocked IPs set
    if !state.blocked_ips.is_empty() {
        rules.push_str("    set blocked_ips {\n");
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        elements = { ");
        rules.push_str(&state.blocked_ips.join(", "));
        rules.push_str(" }\n");
        rules.push_str("    }\n\n");
    }

    // Country sets (placeholder - would need IP ranges)
    for country in &state.blocked_countries {
        rules.push_str(&format!("    # Country: {} ({})\n", country.to_uppercase(), country_name(country)));
        rules.push_str(&format!("    # Download ranges from: https://www.ipdeny.com/ipblocks/data/aggregated/{}-aggregated.zone\n", country));
        rules.push_str(&format!("    set country_{} {{\n", country));
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        # elements = { ... load from zone file ... }\n");
        rules.push_str("    }\n\n");
    }

    // Chain
    rules.push_str("    chain input {\n");
    rules.push_str("        type filter hook input priority 0; policy accept;\n\n");

    // Whitelist rule
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("        # Allow whitelisted IPs\n");
        rules.push_str("        ip saddr @whitelist accept\n\n");
    }

    // Block rules
    if !state.blocked_ips.is_empty() {
        rules.push_str("        # Block specific IPs\n");
        rules.push_str("        ip saddr @blocked_ips drop\n\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!("        # Block {}\n", country_name(country)));
        rules.push_str(&format!("        ip saddr @country_{} drop\n", country));
    }

    rules.push_str("    }\n");
    rules.push_str("}\n");

    Ok(rules)
}

/// Generate iptables rules from state.
pub fn generate_iptables(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("#!/bin/bash\n");
    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Run as root to apply\n\n");

    rules.push_str("# Create chain\n");
    rules.push_str("iptables -N GEOBLOCK 2>/dev/null || iptables -F GEOBLOCK\n\n");

    // Whitelist
    for ip in &state.whitelisted_ips {
        rules.push_str(&format!("# Whitelist\niptables -A GEOBLOCK -s {} -j ACCEPT\n", ip));
    }

    if !state.whitelisted_ips.is_empty() {
        rules.push_str("\n");
    }

    // Block IPs
    for ip in &state.blocked_ips {
        rules.push_str(&format!("iptables -A GEOBLOCK -s {} -j DROP\n", ip));
    }

    // Country blocks (placeholder)
    for country in &state.blocked_countries {
        rules.push_str(&format!("\n# Block {} ({})\n", country_name(country), country.to_uppercase()));
        rules.push_str(&format!("# Download: curl -s https://www.ipdeny.com/ipblocks/data/aggregated/{}-aggregated.zone | while read ip; do\n", country));
        rules.push_str("#   iptables -A GEOBLOCK -s $ip -j DROP\n");
        rules.push_str("# done\n");
    }

    rules.push_str("\n# Insert chain into INPUT\n");
    rules.push_str("iptables -I INPUT -j GEOBLOCK\n");

    Ok(rules)
}

/// Generate pf rules for BSD/macOS.
pub fn generate_pf(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Add to /etc/pf.conf and run: pfctl -f /etc/pf.conf\n\n");

    // Tables
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("table <whitelist> { ");
        rules.push_str(&state.whitelisted_ips.join(", "));
        rules.push_str(" }\n");
    }

    if !state.blocked_ips.is_empty() {
        rules.push_str("table <blocked> { ");
        rules.push_str(&state.blocked_ips.join(", "));
        rules.push_str(" }\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!("# table <{}> {{ ... load from {}-aggregated.zone ... }}\n",
            country, country));
    }

    rules.push_str("\n# Rules\n");

    if !state.whitelisted_ips.is_empty() {
        rules.push_str("pass in quick from <whitelist>\n");
    }

    if !state.blocked_ips.is_empty() {
        rules.push_str("block in quick from <blocked>\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!("# block in quick from <{}>\n", country));
    }

    Ok(rules)
}
